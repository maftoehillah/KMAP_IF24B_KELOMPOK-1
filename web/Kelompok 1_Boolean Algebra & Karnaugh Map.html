<!DOCTYPE html>
<html lang="id">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="description" content="Simulator Aljabar Boolean & Karnaugh Map - Kelompok 1 - Rangkaian Digital" />
<meta name="author" content="Kelompok 1 - Rangkaian Digital" />
<title>Simulator Aljabar Boolean & Karnaugh Map - Kelompok 1</title>
<style>
  
  :root {
    --font-family-body: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
    --font-family-mono: 'JetBrains Mono', 'Fira Mono', Consolas, 'Courier New', monospace;
    --color-bg: #0f0f1e;
    --color-bg-secondary: #1a1a2e;
    --color-surface: rgba(255, 255, 255, 0.05);
    --color-surface-hover: rgba(255, 255, 255, 0.08);
    --color-border: rgba(255, 255, 255, 0.1);
    
    --color-text: #ffffff;
    --color-text-secondary: #a0aec0;
    --color-text-muted: #718096;
    
    --color-primary: #4f46e5;
    --color-primary-light: #6366f1;
    --color-secondary: #ec4899;
    --color-accent: #10b981;
    --color-warning: #f59e0b;
    --color-error: #ef4444;
    
    --gradient-primary: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    --gradient-secondary: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
    --gradient-accent: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
    --gradient-warm: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
    
    --shadow-sm: 0 2px 8px rgba(0, 0, 0, 0.1);
    --shadow-md: 0 4px 16px rgba(0, 0, 0, 0.2);
    --shadow-lg: 0 8px 32px rgba(0, 0, 0, 0.3);
    --shadow-xl: 0 16px 48px rgba(0, 0, 0, 0.4);
    
    --blur-glass: blur(20px);
    --radius-sm: 12px;
    --radius-md: 16px;
    --radius-lg: 24px;
    --radius-xl: 32px;
  }

  [data-theme="light"] {
    --color-bg: #f7fafc;
    --color-bg-secondary: #edf2f7;
    --color-surface: rgba(255, 255, 255, 0.9);
    --color-surface-hover: rgba(255, 255, 255, 1);
    --color-border: rgba(0, 0, 0, 0.1);
    
    --color-text: #1a202c;
    --color-text-secondary: #4a5568;
    --color-text-muted: #718096;
  }

  * {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
  }

  html {
    scroll-behavior: smooth;
  }

  body {
    font-family: var(--font-family-body);
    font-size: 16px;
    line-height: 1.6;
    color: var(--color-text);
    background: var(--color-bg);
    min-height: 100vh;
    overflow-x: hidden;
    position: relative;
  }

  /* Animated Background */
  .bg-animated {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 0;
    overflow: hidden;
    pointer-events: none;
  }

  .bg-shape {
    position: absolute;
    border-radius: 50%;
    filter: blur(80px);
    opacity: 0.3;
    animation: float 20s infinite ease-in-out;
  }

  .bg-shape:nth-child(1) {
    width: 600px;
    height: 600px;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    top: -200px;
    left: -200px;
    animation-delay: 0s;
  }

  .bg-shape:nth-child(2) {
    width: 500px;
    height: 500px;
    background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
    top: 40%;
    right: -150px;
    animation-delay: -7s;
  }

  .bg-shape:nth-child(3) {
    width: 400px;
    height: 400px;
    background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
    bottom: -100px;
    left: 30%;
    animation-delay: -14s;
  }

  @keyframes float {
    0%, 100% {
      transform: translate(0, 0) rotate(0deg);
    }
    33% {
      transform: translate(30px, -30px) rotate(120deg);
    }
    66% {
      transform: translate(-20px, 20px) rotate(240deg);
    }
  }

  /* Header */
  header {
    position: sticky;
    top: 0;
    z-index: 100;
    backdrop-filter: var(--blur-glass);
    background: rgba(15, 15, 30, 0.8);
    border-bottom: 1px solid var(--color-border);
    padding: 20px 0;
  }

  .header-content {
    max-width: 1400px;
    margin: 0 auto;
    padding: 0 24px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 24px;
  }

  .header-brand {
    display: flex;
    align-items: center;
    gap: 16px;
  }

  .brand-icon {
    width: 48px;
    height: 48px;
    background: var(--gradient-primary);
    border-radius: var(--radius-md);
    display: grid;
    place-items: center;
    font-size: 24px;
    box-shadow: var(--shadow-md);
    animation: pulse 3s infinite;
  }

  @keyframes pulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.05); }
  }

  .header-title h1 {
    font-size: 24px;
    font-weight: 700;
    background: var(--gradient-primary);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }

  .header-subtitle {
    font-size: 13px;
    color: var(--color-text-secondary);
    font-family: 'JetBrains Mono', monospace;
  }

  .theme-toggle {
    background: var(--color-surface);
    backdrop-filter: var(--blur-glass);
    border: 1px solid var(--color-border);
    color: var(--color-text);
    padding: 12px;
    width: 44px;
    height: 44px;
    border-radius: 50%;
    cursor: pointer;
    font-size: 18px;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    box-shadow: var(--shadow-sm);
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .theme-toggle:hover {
    background: var(--color-surface-hover);
    transform: translateY(-2px) rotate(15deg);
    box-shadow: var(--shadow-md);
  }

  [data-theme="light"] .theme-toggle {
    transform: rotate(90deg);
  }
  
  [data-theme="light"] .theme-toggle:hover {
    transform: translateY(-2px) rotate(105deg);
  }

  /* Hero Section */
  .hero {
    position: relative;
    z-index: 1;
    max-width: 1400px;
    margin: 0 auto;
    padding: 60px 24px 40px;
    text-align: center;
  }

  .hero h2 {
    font-size: 56px;
    font-weight: 700;
    line-height: 1.2;
    margin-bottom: 24px;
    background: linear-gradient(135deg, #14b0e0 0%, #a0aec0 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }

  .hero p {
    font-size: 20px;
    color: var(--color-text-secondary);
    max-width: 600px;
    margin: 0 auto 40px;
  }

  .hero-badges {
    display: flex;
    gap: 12px;
    justify-content: center;
    flex-wrap: wrap;
  }

  .badge {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    padding: 10px 20px;
    background: var(--color-surface);
    backdrop-filter: var(--blur-glass);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-lg);
    font-size: 14px;
    font-weight: 600;
    color: var(--color-text-secondary);
    transition: all 0.3s ease;
  }

  .badge:hover {
    transform: translateY(-2px);
    box-shadow: var(--shadow-md);
    border-color: var(--color-primary);
  }

  /* Container */
  .container {
    position: relative;
    z-index: 1;
    max-width: 1400px;
    margin: 0 auto;
    padding: 0 24px 40px;
  }

  /* Main Grid Layout */
  .main-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 24px;
    margin-bottom: 24px;
  }

  /* Stats Grid */
  .stats-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    gap: 20px;
    margin-bottom: 40px;
  }

  .stat-card {
    background: var(--color-surface);
    backdrop-filter: var(--blur-glass);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-lg);
    padding: 32px;
    text-align: center;
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    box-shadow: var(--shadow-sm);
    position: relative;
    overflow: hidden;
  }

  .stat-card::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 4px;
    background: var(--gradient-primary);
    transform: scaleX(0);
    transition: transform 0.4s ease;
  }

  .stat-card:hover {
    transform: translateY(-8px) scale(1.02);
    box-shadow: var(--shadow-xl);
    border-color: var(--color-primary);
  }

  .stat-card:hover::before {
    transform: scaleX(1);
  }

  .stat-icon {
    font-size: 40px;
    margin-bottom: 12px;
    animation: bounce 2s infinite;
  }

  @keyframes bounce {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-10px); }
  }

  .stat-value {
    font-size: 48px;
    font-weight: 700;
    background: var(--gradient-accent);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    margin-bottom: 8px;
    font-family: 'JetBrains Mono', monospace;
  }

  .stat-label {
    font-size: 14px;
    color: var(--color-text-secondary);
    font-weight: 600;
  }

  /* Glass Card */
  .glass-card {
    background: var(--color-surface);
    backdrop-filter: var(--blur-glass);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-xl);
    padding: 32px;
    box-shadow: var(--shadow-lg);
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    position: relative;
    overflow: hidden;
    margin-bottom: 24px;
  }

  .glass-card::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 200px;
    background: radial-gradient(circle at 50% 0%, rgba(102, 126, 234, 0.1), transparent);
    pointer-events: none;
  }

  .glass-card:hover {
    transform: translateY(-4px);
    box-shadow: var(--shadow-xl);
    border-color: var(--color-primary);
  }

  .card-header {
    display: flex;
    align-items: center;
    gap: 16px;
    margin-bottom: 28px;
    position: relative;
    z-index: 1;
  }

  .card-icon {
    width: 56px;
    height: 56px;
    background: var(--gradient-primary);
    border-radius: var(--radius-md);
    display: grid;
    place-items: center;
    font-size: 28px;
    box-shadow: var(--shadow-md);
  }

  .card-header h2 {
    font-size: 24px;
    font-weight: 700;
    color: var(--color-text);
    margin: 0;
  }

  /* Form Elements */
  .field {
    display: grid;
    gap: 12px;
    margin: 24px 0;
    position: relative;
    z-index: 1;
  }

  label {
    font-size: 14px;
    font-weight: 600;
    color: var(--color-text-secondary);
    display: flex;
    align-items: center;
    gap: 8px;
  }

  input[type="text"],
  textarea,
  select {
    width: 100%;
    padding: 16px 20px;
    background: rgba(255, 255, 255, 0.03);
    color: var(--color-text);
    border: 2px solid var(--color-border);
    border-radius: var(--radius-md);
    outline: none;
    font-family: var(--font-family-mono);
    font-size: 15px;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    backdrop-filter: var(--blur-glass);
  }

  input[type="text"]:focus,
  textarea:focus,
  select:focus {
    border-color: var(--color-primary);
    background: rgba(255, 255, 255, 0.06);
    box-shadow: 0 0 0 4px rgba(79, 70, 229, 0.1);
    transform: translateY(-2px);
  }

  textarea {
    min-height: 100px;
    resize: vertical;
  }

  /* Buttons */
  .actions {
    display: flex;
    flex-wrap: wrap;
    gap: 12px;
    margin: 24px 0;
    position: relative;
    z-index: 1;
  }

  button {
    position: relative;
    background: var(--gradient-primary);
    color: white;
    border: none;
    padding: 14px 28px;
    border-radius: var(--radius-lg);
    font-weight: 700;
    font-size: 15px;
    cursor: pointer;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    box-shadow: var(--shadow-md);
    overflow: hidden;
  }

  button::before {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 0;
    height: 0;
    background: rgba(255, 255, 255, 0.3);
    border-radius: 50%;
    transform: translate(-50%, -50%);
    transition: width 0.6s, height 0.6s;
  }

  button:hover::before {
    width: 300px;
    height: 300px;
  }

  button:hover {
    transform: translateY(-4px) scale(1.05);
    box-shadow: var(--shadow-xl);
  }

  button:active {
    transform: translateY(-2px) scale(1.02);
  }

  button.secondary {
    background: var(--color-surface);
    color: var(--color-text);
    border: 2px solid var(--color-border);
  }

  button.secondary:hover {
    border-color: var(--color-primary);
    background: var(--color-surface-hover);
  }

  button.warn {
    background: var(--gradient-warm);
  }

  button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    transform: none;
  }

  /* Examples */
  .examples {
    display: flex;
    flex-wrap: wrap;
    gap: 12px;
    margin: 24px 0;
    position: relative;
    z-index: 1;
  }

  .example-btn {
    background: var(--color-surface);
    backdrop-filter: var(--blur-glass);
    color: var(--color-text);
    border: 2px solid var(--color-border);
    padding: 12px 20px;
    border-radius: var(--radius-md);
    font-size: 13px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    font-family: 'JetBrains Mono', monospace;
  }

  .example-btn:hover {
    background: var(--gradient-primary);
    border-color: transparent;
    color: white;
    transform: translateY(-2px);
    box-shadow: var(--shadow-md);
  }

  /* Pills */
  .pill {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    background: var(--color-surface);
    backdrop-filter: var(--blur-glass);
    color: var(--color-text);
    padding: 10px 20px;
    border-radius: var(--radius-lg);
    font-size: 13px;
    font-weight: 600;
    border: 2px solid var(--color-border);
    font-family: 'JetBrains Mono', monospace;
    transition: all 0.3s ease;
  }

  .pill:hover {
    transform: translateY(-2px);
    box-shadow: var(--shadow-sm);
  }

  .legend {
    display: flex;
    flex-wrap: wrap;
    gap: 12px;
    align-items: center;
    margin: 20px 0;
    position: relative;
    z-index: 1;
  }

  /* Table */
  .tt {
    border: 2px solid var(--color-border);
    border-radius: var(--radius-lg);
    overflow: hidden;
    box-shadow: var(--shadow-md);
    max-height: 400px;
    overflow-y: auto;
    background: var(--color-surface);
    backdrop-filter: var(--blur-glass);
  }

  table {
    width: 100%;
    border-collapse: collapse;
    font-family: 'JetBrains Mono', monospace;
    font-size: 14px;
  }

  th,
  td {
    text-align: center;
    padding: 16px 12px;
    border-bottom: 1px solid var(--color-border);
  }

  th {
    background: rgba(79, 70, 229, 0.1);
    font-weight: 700;
    color: var(--color-text);
    position: sticky;
    top: 0;
    z-index: 10;
    backdrop-filter: var(--blur-glass);
  }

  tbody tr {
    transition: all 0.2s ease;
  }

  tbody tr:hover {
    background: var(--color-surface-hover);
    transform: scale(1.01);
  }

  /* K-Map */
  .kmap {
    display: grid;
    gap: 12px;
    justify-content: center;
    align-content: center;
    margin: 24px 0;
    padding: 32px;
    background: var(--color-surface);
    backdrop-filter: var(--blur-glass);
    border-radius: var(--radius-lg);
    border: 2px solid var(--color-border);
    box-shadow: var(--shadow-md);
  }

  .kcell {
    width: 72px;
    height: 72px;
    display: grid;
    place-items: center;
    border: 3px solid var(--color-border);
    border-radius: var(--radius-md);
    background: rgba(255, 255, 255, 0.03);
    backdrop-filter: var(--blur-glass);
    color: var(--color-text);
    cursor: pointer;
    user-select: none;
    font-weight: 700;
    font-size: 20px;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    font-family: 'JetBrains Mono', monospace;
    position: relative;
    overflow: hidden;
  }

  .kcell::after {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 0;
    height: 0;
    background: rgba(255, 255, 255, 0.2);
    border-radius: 50%;
    transform: translate(-50%, -50%);
    transition: width 0.4s, height 0.4s;
  }

  .kcell:hover::after {
    width: 100px;
    height: 100px;
  }

  .kcell:hover {
    transform: translateY(-4px) scale(1.1);
    box-shadow: var(--shadow-lg);
    border-color: var(--color-primary);
  }

  .kcell.on {
    background: var(--gradient-accent);
    border-color: #00f2fe;
    color: white;
    box-shadow: 0 0 30px rgba(0, 242, 254, 0.4);
    animation: glow 2s infinite;
  }

  @keyframes glow {
    0%, 100% { box-shadow: 0 0 30px rgba(0, 242, 254, 0.4); }
    50% { box-shadow: 0 0 40px rgba(0, 242, 254, 0.6); }
  }

  .kcell.dc {
    background: var(--gradient-warm);
    border-color: #fee140;
    color: white;
    box-shadow: 0 0 30px rgba(254, 225, 64, 0.4);
  }

  .kcell:active {
    transform: scale(0.95);
  }

  .klabel {
    font-size: 14px;
    color: var(--color-text-secondary);
    font-weight: 700;
    font-family: 'JetBrains Mono', monospace;
    text-transform: uppercase;
    letter-spacing: 1px;
  }

  .gridwrap {
    display: flex;
    gap: 32px;
    align-items: center;
    margin: 20px 0;
    flex-wrap: wrap;
    justify-content: center;
  }

  .gridlabels {
    display: flex;
    gap: 12px;
    align-items: center;
  }

  /* Code */
  code,
  .code {
    font-family: 'JetBrains Mono', monospace;
    background: rgba(79, 70, 229, 0.1);
    color: var(--color-text);
    padding: 16px 20px;
    border-radius: var(--radius-md);
    border: 2px solid var(--color-border);
    display: block;
    font-size: 14px;
    line-height: 1.8;
    backdrop-filter: var(--blur-glass);
  }

  /* Mode Toggle */
  .mode-toggle {
    display: flex;
    background: var(--color-surface);
    backdrop-filter: var(--blur-glass);
    border-radius: var(--radius-lg);
    padding: 6px;
    border: 2px solid var(--color-border);
    margin: 20px 0;
    gap: 6px;
  }

  .mode-toggle button {
    background: transparent;
    color: var(--color-text-secondary);
    border: none;
    padding: 12px 24px;
    border-radius: var(--radius-md);
    font-size: 14px;
    font-weight: 700;
    transition: all 0.3s ease;
    box-shadow: none;
  }

  .mode-toggle button:hover {
    transform: none;
    background: var(--color-surface-hover);
  }

  .mode-toggle button.active {
    background: var(--gradient-primary);
    color: white;
    box-shadow: var(--shadow-sm);
  }

  /* State Legend */
  .state-legend {
    display: flex;
    gap: 20px;
    align-items: center;
    margin: 20px 0;
    flex-wrap: wrap;
    justify-content: center;
  }

  .state-box {
    display: flex;
    align-items: center;
    gap: 12px;
    font-size: 14px;
    font-weight: 600;
    padding: 12px 20px;
    background: var(--color-surface);
    backdrop-filter: var(--blur-glass);
    border: 2px solid var(--color-border);
    border-radius: var(--radius-md);
    transition: all 0.3s ease;
  }

  .state-box:hover {
    transform: translateY(-2px);
    box-shadow: var(--shadow-sm);
  }

  .state-sample {
    width: 32px;
    height: 32px;
    border-radius: var(--radius-sm);
    border: 2px solid var(--color-border);
  }

  /* Messages */
  .error-message,
  .success-message {
    padding: 16px 24px;
    border-radius: var(--radius-md);
    margin-top: 16px;
    font-size: 14px;
    font-weight: 600;
    display: none;
    backdrop-filter: var(--blur-glass);
    border: 2px solid;
  }

  .error-message {
    background: rgba(239, 68, 68, 0.1);
    color: var(--color-error);
    border-color: var(--color-error);
  }

  .success-message {
    background: rgba(16, 185, 129, 0.1);
    color: var(--color-accent);
    border-color: var(--color-accent);
  }

  .error-message.show,
  .success-message.show {
    display: block;
    animation: slideInUp 0.4s cubic-bezier(0.4, 0, 0.2, 1);
  }

  @keyframes slideInUp {
    from {
      opacity: 0;
      transform: translateY(20px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  /* Benchmark */
  .benchmark {
    background: var(--color-surface);
    backdrop-filter: var(--blur-glass);
    border: 2px solid var(--color-border);
    border-radius: var(--radius-md);
    padding: 20px;
    margin: 20px 0;
    display: flex;
    gap: 24px;
    align-items: center;
    font-size: 13px;
    font-weight: 600;
    flex-wrap: wrap;
  }

  /* Help Section */
  .help-section {
    background: var(--color-surface);
    backdrop-filter: var(--blur-glass);
    border: 2px solid var(--color-border);
    border-radius: var(--radius-lg);
    padding: 28px;
    margin: 20px 0;
  }

  .help-section h4 {
    color: var(--color-text);
    font-size: 18px;
    font-weight: 700;
    margin-bottom: 16px;
    display: flex;
    align-items: center;
    gap: 12px;
  }

  .help-section ul {
    padding-left: 24px;
  }

  .help-section li {
    margin: 12px 0;
    font-size: 15px;
    line-height: 1.8;
    color: var(--color-text-secondary);
  }

  /* Member Cards */
  .member-card {
    background: var(--color-surface);
    backdrop-filter: var(--blur-glass);
    border: 2px solid var(--color-border);
    border-left: 6px solid var(--color-primary);
    border-radius: var(--radius-lg);
    padding: 24px;
    margin: 16px 0;
    transition: all 0.3s ease;
  }

  .member-card:hover {
    transform: translateX(8px);
    box-shadow: var(--shadow-lg);
    border-left-color: var(--color-secondary);
  }

  .member-card b {
    color: var(--color-primary);
  }

  /* Footer */
  .footer {
    text-align: center;
    padding: 40px 24px;
    color: var(--color-text-muted);
    font-size: 14px;
    border-top: 2px solid var(--color-border);
    margin-top: 60px;
    background: var(--color-surface);
    backdrop-filter: var(--blur-glass);
  }

  /* Tooltip */
  .tooltip-icon {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: var(--gradient-primary);
    color: white;
    font-size: 12px;
    font-weight: 700;
    cursor: help;
    position: relative;
    margin-left: 8px;
  }

  .tooltip-icon:hover::after {
    content: attr(data-tip);
    position: absolute;
    top: 100%;
    left: 50%;
    transform: translateX(-50%) translateY(-100%);
    background: linear-gradient(145deg, var(--color-bg-secondary) 0%, rgba(26,26,46,0.95) 100%);
    color: var(--color-text);
    padding: 16px 20px;
    border-radius: var(--radius-md);
    max-width: 300px; 
    width: max-content; 
    white-space: normal; 
    font-size: 13px;
    line-height: 1.5;
    font-weight: 500;
    z-index: 9999;
    text-align: center;
    border: 1px transparent rgba(255,255,255,0.1);
    box-shadow: 
      0 0 0 1px rgba(255,255,255,0.05),
      0 4px 6px -1px rgba(0,0,0,0.1),
      0 2px 4px -1px rgba(0,0,0,0.06),
      inset 0 1px 1px rgba(255,255,255,0.1),
      0 0 20px rgba(79,70,229,0.1);
    backdrop-filter: var(--blur-glass);
    pointer-events: none;
    opacity: 0;
    visibility: hidden;
    transform-origin: top center;
    animation: tooltipIn 0.2s ease forwards;
  }

  .tooltip-icon:hover::before {
    content: '';
    position: absolute;
    top: -10px;
    left: 50%;
    transform: translateX(-50%);
    border-width: 6px;
    border-style: solid;
    border-color: var(--color-bg-secondary) transparent transparent transparent;
    z-index: 9999;
    animation: tooltipPointerIn 0.2s ease forwards;
  }

  @keyframes tooltipIn {
    from {
      opacity: 0;
      visibility: visible;
      transform: translateX(-50%) translateY(-90%) scale(0.95);
    }
    to {
      opacity: 1;
      visibility: visible;
      transform: translateX(-50%) translateY(-100%) scale(1);
      filter: drop-shadow(0 20px 30px rgba(0,0,0,0.25));
    }
  }

  @keyframes tooltipPointerIn {
    from {
      opacity: 0;
      transform: translateX(-50%) translateY(-5px);
    }
    to {
      opacity: 1;
      transform: translateX(-50%) translateY(0);
    }
  }

  .tooltip-icon:not(:hover)::after {
    animation: tooltipOut 0.2s ease forwards;
  }

  .tooltip-icon:not(:hover)::before {
    animation: tooltipPointerOut 0.2s ease forwards;
  }

  @keyframes tooltipOut {
    from {
      opacity: 1;
      visibility: visible;
      transform: translateX(-50%) translateY(-100%) scale(1);
      filter: drop-shadow(0 20px 30px rgba(0,0,0,0.25));
    }
    to {
      opacity: 0;
      visibility: hidden;
      transform: translateX(-50%) translateY(-90%) scale(0.95);
      filter: drop-shadow(0 0 0 rgba(0,0,0,0));
    }
  }

  @keyframes tooltipPointerOut {
    from {
      opacity: 1;
      transform: translateX(-50%) translateY(0);
    }
    to {
      opacity: 0;
      transform: translateX(-50%) translateY(-5px);
    }
  }

  /* Scrollbar */
  ::-webkit-scrollbar {
    width: 12px;
  }

  ::-webkit-scrollbar-track {
    background: var(--color-bg-secondary);
  }

  ::-webkit-scrollbar-thumb {
    background: var(--gradient-primary);
    border-radius: 6px;
  }

  ::-webkit-scrollbar-thumb:hover {
    background: var(--gradient-secondary);
  }

  /* Responsive */
  @media (max-width: 1024px) {
    .hero h2 {
      font-size: 42px;
    }

    .main-grid {
      grid-template-columns: 1fr;
    }
  }

  @media (max-width: 768px) {
    .hero h2 {
      font-size: 32px;
    }

    .hero p {
      font-size: 16px;
    }

    .glass-card {
      padding: 24px;
    }

    .kcell {
      width: 60px;
      height: 60px;
      font-size: 16px;
    }

    .stats-grid {
      grid-template-columns: 1fr;
    }

    .main-grid {
      grid-template-columns: 1fr;
    }
  }

  @media (max-width: 480px) {
    .hero h2 {
      font-size: 28px;
    }

    .actions {
      flex-direction: column;
    }

    .examples {
      flex-direction: column;
    }

    button {
      width: 100%;
    }
  }

  /* Loading Animation */
  @keyframes shimmer {
    0% {
      background-position: -1000px 0;
    }
    100% {
      background-position: 1000px 0;
    }
  }

  .loading {
    background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
    background-size: 1000px 100%;
    animation: shimmer 2s infinite;
  }
</style>
</head>
<body data-theme="dark">
<!-- Animated Background -->
<div class="bg-animated">
  <div class="bg-shape"></div>
  <div class="bg-shape"></div>
  <div class="bg-shape"></div>
</div>

<header>
  <div class="header-content">
    <div class="header-brand">
      <div class="brand-icon">üßÆ</div>
      <div class="header-title">
        <h1>Boolean Algebra & Karnaugh Map</h1>
        <div class="header-subtitle">Kelompok 1 ‚Äî Rangkaian Digital</div>
      </div>
    </div>
    <button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme">üåô</button>
  </div>
</header>

<!-- Hero Section -->
<div class="hero">
  <h2>Boolean Algebra & Karnaugh Map<br>Simulator</h2>
  <p>Visualisasi ekspresi Boolean, generate tabel kebenaran otomatis, dan sederhanakan dengan algoritma Quine-McCluskey</p>
  <div class="hero-badges">
    <div class="badge">‚ö° Real-time Evaluation</div>
    <div class="badge">üó∫Ô∏è Interactive K-Map</div>
    <div class="badge">üéØ Auto Simplification</div>
    <div class="badge">üìä Truth Table Generator</div>
  </div>
</div>

<div class="container">
  <!-- Statistics Overview -->
  <div class="stats-grid">
    <div class="stat-card">
      <div class="stat-icon">‚ö°</div>
      <div class="stat-value" id="stat-evaluations">0</div>
      <div class="stat-label">Total Evaluations</div>
    </div>
    <div class="stat-card">
      <div class="stat-icon">üî§</div>
      <div class="stat-value" id="stat-vars">0</div>
      <div class="stat-label">Variables Detected</div>
    </div>
    <div class="stat-card">
      <div class="stat-icon">üéØ</div>
      <div class="stat-value" id="stat-minterms">0</div>
      <div class="stat-label">Active Minterms</div>
    </div>
    <div class="stat-card">
      <div class="stat-icon">‚è±Ô∏è</div>
      <div class="stat-value" id="stat-time">0ms</div>
      <div class="stat-label">Last QM Time</div>
    </div>
  </div>

  <!-- Main Grid: Expression Evaluator & K-Map Visualizer -->
  <div class="main-grid">
    <!-- Boolean Expression Evaluator -->
    <div class="glass-card">
      <div class="card-header">
        <div class="card-icon">üßÆ</div>
        <h2>Boolean Expression Evaluator</h2>
      </div>
      
      <div class="examples">
        <div class="mini" style="width: 100%; margin-bottom: 12px; color: var(--color-text-secondary); font-size: 14px;">üìö Quick Examples (click to try):</div>
        <button class="example-btn" data-expr="A'B + AC">F‚ÇÅ: A'B + AC</button>
        <button class="example-btn" data-expr="A(B+C)">F‚ÇÇ: A(B+C)</button>
        <button class="example-btn" data-expr="(A^B)C + A'B'">F‚ÇÉ: (A‚äïB)C + A'B'</button>
        <button class="example-btn" data-expr="(A+B)*(C+D)">F‚ÇÑ: (A+B)(C+D)</button>
        <button class="example-btn" data-expr="A'B' + AB">F‚ÇÖ: A'B' + AB</button>
        <button class="example-btn" data-expr="A^B^C">F‚ÇÜ: A‚äïB‚äïC</button>
        <button class="example-btn" data-expr="(A+B'*C')*(A'+C)">F‚Çá: (A+B'C')(A'+C)</button>
        <button class="example-btn" data-expr="~(A*B) + C">F‚Çà: (AB)' + C</button>
        <button class="example-btn" data-expr="AB + AC + BC">F‚Çâ: AB+AC+BC</button>
        <button class="example-btn" data-expr="(A+B+C)*(A'+B)*(B+C')">F‚ÇÅ‚ÇÄ: (A+B+C)(A'+B)(B+C')</button>
      </div>
      
      <div class="field">
        <label for="expr">
          Boolean Expression
          <span class="tooltip-icon" data-tip="Boolean expression using variables A-D and operators: NOT (', !, ~), AND (*, &), OR (+, |), XOR (^)">?</span>
        </label>
        <input id="expr" type="text" placeholder="Example: A'B + AC + B(C^D)" value="A'B + AC" autocomplete="off"/>
        <div id="error-message" class="error-message"></div>
        <div id="success-message" class="success-message"></div>
      </div>
      
      <div class="actions">
        <button id="btn-eval">‚ö° Evaluate Expression</button>
        <button id="btn-clear" class="secondary">üóëÔ∏è Clear All</button>
        <button id="btn-validate" class="secondary">‚úì Validate Syntax</button>
      </div>
      
      <div class="legend">
        <span class="pill" id="vars-pill">üìä Variables: ‚Äî</span>
        <span class="pill" id="minterms-pill">üéØ Minterms: ‚Äî</span>
      </div>
      <div class="benchmark" id="benchmark" style="display: none;">
        <span>‚è±Ô∏è Time: <b id="bench-time">‚Äî</b></span>
        <span>üìä Cells: <b id="bench-cells">‚Äî</b></span>
        <span>üéØ Complexity: <b id="bench-complexity">‚Äî</b></span>
      </div>
      
      <h3 style="margin: 32px 0 16px; font-size: 20px; font-weight: 700; color: var(--color-text);">üìã Truth Table</h3>
      <div class="tt"><table id="ttbl"><thead></thead><tbody></tbody></table></div>
    </div>

    <!-- Karnaugh Map Visualizer -->
    <div class="glass-card">
      <div class="card-header">
        <div class="card-icon">üó∫Ô∏è</div>
        <h2>Karnaugh Map Visualizer
          <span class="tooltip-icon" data-tip="Click cells to toggle value: Off (0) ‚Üí On (1) ‚Üí Don't Care (d)">?</span>
        </h2>
      </div>
      
      <div class="state-legend">
        <div class="state-box">
          <div class="state-sample" style="background: rgba(255, 255, 255, 0.03);"></div>
          <span>0 (Off)</span>
        </div>
        <div class="state-box">
          <div class="state-sample" style="background: var(--gradient-accent);"></div>
          <span>1 (On)</span>
        </div>
        <div class="state-box">
          <div class="state-sample" style="background: var(--gradient-warm);"></div>
          <span>d (Don't Care)</span>
        </div>
      </div>
      
      <div class="gridwrap">
        <div class="gridlabels">
          <div class="klabel">üìç Row:</div>
          <div class="klabel" id="rowlabel">‚Äî</div>
        </div>
        <div class="gridlabels">
          <div class="klabel">üìç Col:</div>
          <div class="klabel" id="collabel">‚Äî</div>
        </div>
      </div>
      
      <div id="kmap" class="kmap"></div>
      
      <div class="mode-toggle">
        <button id="mode-sop" class="active">üìê SOP Mode</button>
        <button id="mode-pos">üìè POS Mode</button>
      </div>
      
      <div class="actions">
        <button id="btn-simplify">‚ú® Simplify (QM)</button>
        <button id="btn-reset" class="secondary">‚Üª Reset K-Map</button>
        <button id="btn-export-img" class="secondary">üì∑ Export PNG</button>
      </div>
      
      <div class="field">
        <label id="result-label">üéØ Simplification Result (SOP)
          <span class="tooltip-icon" data-tip="Result shows minimized expression using Quine-McCluskey algorithm with essential prime implicants">?</span>
        </label>
        <div id="out-simplified" class="code">‚Äî</div>
      </div>
      
      <div class="field">
        <label id="minterm-label">
          üì• Import/Export Minterms
          <span class="tooltip-icon" data-tip="Enter minterms as comma-separated numbers. For don't cares, add +d(2,3). Example: 1,3,5,7+d(2,4)">?</span>
        </label>
        <input id="minterm-io" type="text" placeholder="Example: 0,1,2,5,7 or 1,3,5+d(2,4)" autocomplete="off"/>
        <div class="actions">
          <button id="btn-import" class="secondary">üì• Import ‚Üí K-Map</button>
          <button id="btn-export" class="secondary">üì§ Export from K-Map</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Documentation & Guide -->
  <div class="glass-card">
    <div class="card-header">
      <div class="card-icon">üìö</div>
      <h2>Documentation & Guide</h2>
    </div>
    <div class="help-section">
      <h4>üöÄ How to Use:</h4>
      <ul>
        <li><b>Input Expression:</b> Type Boolean expression or click example buttons</li>
        <li><b>Supported Operators:</b>
          <ul style="margin-top: 8px;">
            <li>NOT: <code>'</code> (postfix), <code>!</code> <code>~</code> (prefix)</li>
            <li>AND: <code>*</code> <code>&</code> or implicit (AB = A*B)</li>
            <li>OR: <code>+</code> <code>|</code></li>
            <li>XOR: <code>^</code></li>
            <li>Parentheses: <code>( )</code> for priority</li>
          </ul>
        </li>
        <li><b>Evaluation:</b> Click "‚ö° Evaluate" to generate truth table and K-Map</li>
        <li><b>Interactive K-Map:</b> Click cells to toggle values (0 ‚Üí 1 ‚Üí d)</li>
        <li><b>SOP/POS Mode:</b> Choose Sum of Products or Product of Sums mode</li>
        <li><b>Simplification:</b> Quine-McCluskey algorithm finds minimal form automatically</li>
        <li><b>Import/Export:</b> Import minterm list (format: 0,1,5,7) or export current K-Map</li>
        <li><b>Export PNG:</b> Save K-Map visualization as PNG image</li>
      </ul>
    </div>
    
    <div class="help-section">
      <h4>‚öôÔ∏è Technical Specifications:</h4>
      <ul>
        <li><b>Variables:</b> Up to 8 variables (A-H) for truth tables</li>
        <li><b>K-Map:</b> Optimal visualization for 1-4 variables with Gray code ordering</li>
        <li><b>Algorithm:</b> Quine-McCluskey for SOP/POS minimization with O(3‚Åø√ón¬≤) complexity</li>
        <li><b>Parser:</b> Shunting-yard algorithm for infix to RPN conversion</li>
        <li><b>Don't Care:</b> Full support for don't care conditions in minimization</li>
        <li><b>Validation:</b> Comprehensive error handling with informative messages</li>
        <li><b>Performance:</b> QM algorithm execution time benchmarking</li>
      </ul>
    </div>
    
<!-- member cards -->
  <div class="glass-card">
    <div class="card-header">
      <div class="card-icon">üë•</div>
      <h2>Team Members - Kelompok 1</h2>
    </div>
    <div class="member-card">
      <b>Name:</b> Ahmad Sabiq Maftuhillah<br>
      <b>NIM:</b> 23424014<br>
      <b>Team Role:</b> Lead Developer & UI/UX<br>
      <b>Concise Contribution:</b> Web Development & Design<br>
      <b>Core Responsibility Areas:</b> Frontend (HTML/CSS/JS), UI/UX, K-Map Visualization, Real-time Error Handling, Feature Integration.
    </div>
    <div class="member-card">
      <b>Name:</b> Derril Agusti Fachrezy<br>
      <b>NIM:</b> 23424044<br>
      <b>Team Role:</b> Algorithm & Testing Specialist<br>
      <b>Concise Contribution:</b> Logic, QA, & Accuracy<br>
      <b>Core Responsibility Areas:</b> Core Algorithms (QM/Parser), Don't Care implementation, Quality Assurance (QA), Funtional Testing, and ensuring mathematical precision.
    </div>
    <div class="member-card">
      <b>Name:</b> Dhini rizqa hafizhah<br>
      <b>NIM:</b> 23424040<br>
      <b>Team Role:</b> Technical Writer & Presenter<br>
      <b>Concise Contribution:</b> Documentation & Communication<br>
      <b>Core Responsibility Areas:</b> Writing the Scientific Paper (IMRaD), Creating the Presentation (PPT), and leading project communication and demonstration.
    </div>
    <div style="margin-top: 24px; padding: 20px; background: var(--color-surface); backdrop-filter: var(--blur-glass); border-radius: var(--radius-md); font-size: 14px; border: 2px solid var(--color-border);">
      <b>üìÖ Project Information:</b><br>
      <b>Assignment:</b> Boolean Algebra & Karnaugh Map Simulator | <b>Date:</b> November 2025 | <b>Course:</b> Digital Circuits<br>
      <b>Lecturer:</b> Dr. Arda Surya Editya, S.Pd., MT. | <b>University:</b> Universitas Nahdlatul Ulama Sidoarjo<br>
      <b>Technology:</b> HTML5, CSS3, JavaScript (Vanilla) - No External Libraries
    </div>
  </div>
</div>

<div class="footer">
  ¬© 2025 Kelompok 1 - Digital Circuits. Developed for Academic Purpose.<br>
  Boolean Algebra & Karnaugh Map Simulator with Quine-McCluskey Algorithm
</div>

<script>
/* =============================================================================
   BOOLEAN ALGEBRA & KARNAUGH MAP SIMULATOR
   Kelompok 1 - Rangkaian Digital
   
   DESKRIPSI:
   Aplikasi web interaktif untuk evaluasi ekspresi Boolean, generate tabel
   kebenaran, visualisasi K-Map dengan Gray code, dan minimasi menggunakan
   algoritma Quine-McCluskey.
   
   STRUKTUR KODE:
   1. Constants & Utilities (Gray Code, Helper Functions)
   2. Tokenizer & Parser (Shunting-Yard Algorithm)
   3. RPN Evaluator
   4. Quine-McCluskey Algorithm (SOP & POS)
   5. K-Map Layout & Rendering
   6. Truth Table Generation
   7. Application State Management
   8. Event Handlers & UI Updates
   9. Statistics Tracking
   10. Image Export Functionality
   
   ALGORITMA UTAMA:
   - Shunting-Yard: Konversi infix ‚Üí RPN (O(n))
   - Quine-McCluskey: Minimasi Boolean (O(3^n √ó n¬≤))
   - Gray Code: Ordering optimal untuk K-Map adjacency
   
============================================================================= */

'use strict';

/* =============================================================================
   1. CONSTANTS & UTILITIES
============================================================================= */
const GRAY2 = [0, 1];                    // 2-bit Gray: 00, 01
const GRAY4 = [0, 1, 3, 2];              // 4-bit Gray: 00, 01, 11, 10
const MAX_VARS = 4;                       // K-Map maximum variables
const MAX_TRUTH_TABLE_VARS = 8;           // Truth table maximum

// DOM Element Cache
const $ = id => document.getElementById(id);
const toBin = (n, width) => n.toString(2).padStart(width, '0');

/**
 * Extract and sort unique variables from expression
 * @param {Array} vars - Array of variable characters
 * @returns {Array} Sorted unique variables
 */
function uniqueSortedVars(vars) {
  const set = new Set(vars.map(v => v.toUpperCase()));
  return Array.from(set).sort();
}

/**
 * Extract all variables from expression string
 * @param {string} expr - Boolean expression
 * @returns {Array} Array of unique sorted variables
 */
function extractVars(expr) {
  const vars = (expr.match(/[A-Za-z]/g) || []).map(ch => ch.toUpperCase());
  return uniqueSortedVars(vars);
}

/* =============================================================================
   2. TOKENIZER (Lexical Analysis)
   Converts expression string into tokens
============================================================================= */
function tokenize(raw) {
  const src = raw.replace(/\s+/g, '');    // Remove whitespace
  const tokens = [];
  let i = 0;

  while (i < src.length) {
    const ch = src[i];

    // Number literals (0 or 1)
    if (ch === '0' || ch === '1') {
      tokens.push({ type: 'NUM', value: Number(ch) });
      i++;
      continue;
    }

    // Variables (A-Z, case insensitive)
    if (/[A-Za-z]/.test(ch)) {
      const v = ch.toUpperCase();
      tokens.push({ type: 'VAR', value: v });
      i++;
      
      // Postfix NOT (') - dapat berulang (A'', A''')
      let negCount = 0;
      while (src[i] === "'") {
        negCount++;
        i++;
      }
      // Odd number of ' means NOT
      if (negCount % 2 === 1) {
        tokens.push({
          type: 'OP',
          value: 'NOT',
          unary: true,
          postfix: true,
          precedence: 4,
          associativity: 'right'
        });
      }
      continue;
    }

    // Parentheses
    if (ch === '(') {
      tokens.push({ type: 'LP' });
      i++;
      continue;
    }
    if (ch === ')') {
      tokens.push({ type: 'RP' });
      i++;
      continue;
    }

    // Prefix NOT operators (!, ~)
    if (ch === '!' || ch === '~') {
      tokens.push({
        type: 'OP',
        value: 'NOT',
        unary: true,
        precedence: 4,
        associativity: 'right'
      });
      i++;
      continue;
    }

    // Binary operators
    if ('&*+|^'.includes(ch)) {
      let op;
      if (ch === '&' || ch === '*') op = 'AND';
      else if (ch === '+' || ch === '|') op = 'OR';
      else if (ch === '^') op = 'XOR';
      
      // Precedence: OR(1) < XOR(2) < AND(3) < NOT(4)
      const prec = op === 'OR' ? 1 : (op === 'XOR' ? 2 : 3);
      
      tokens.push({
        type: 'OP',
        value: op,
        precedence: prec,
        associativity: 'left'
      });
      i++;
      continue;
    }

    throw new Error(`Karakter tidak dikenali pada posisi ${i}: '${ch}'`);
  }
  return tokens;
}

/* =============================================================================
   3. PARSER (Shunting-Yard Algorithm)
   Converts infix notation to RPN (Reverse Polish Notation)
============================================================================= */

/**
 * Check if token represents an operand
 */
function isOperand(tok) {
  return tok && (
    tok.type === 'VAR' || 
    tok.type === 'NUM' || 
    tok.type === 'RP' || 
    (tok.type === 'OP' && tok.postfix)
  );
}

/**
 * Check if token can begin an operand/expression
 */
function beginsOperand(tok) {
  return tok && (
    tok.type === 'VAR' || 
    tok.type === 'NUM' || 
    tok.type === 'LP' || 
    (tok.type === 'OP' && tok.value === 'NOT' && !tok.postfix)
  );
}

/**
 * Convert infix tokens to RPN using Shunting-Yard algorithm
 * Supports implicit AND between adjacent operands
 * @param {Array} tokens - Array of tokens from tokenizer
 * @returns {Array} Tokens in RPN order
 */
function toRPN(tokens) {
  const output = [];
  const stack = [];
  const withImplicit = [];
  
  // Phase 1: Insert implicit AND operators
  for (let i = 0; i < tokens.length; i++) {
    withImplicit.push(tokens[i]);
    const a = tokens[i];
    const b = tokens[i + 1];
    
    // Insert implicit AND between: )( , )VAR , VAR( , VARVAR , NUMVAR , etc.
    if (isOperand(a) && beginsOperand(b)) {
      withImplicit.push({
        type: 'OP',
        value: 'AND',
        precedence: 3,
        associativity: 'left',
        implicit: true
      });
    }
  }

  // Phase 2: Shunting-Yard algorithm
  for (let i = 0; i < withImplicit.length; i++) {
    const t = withImplicit[i];
    
    // Operands go directly to output
    if (t.type === 'VAR' || t.type === 'NUM') {
      output.push(t);
      continue;
    }
    
    // Postfix NOT
    if (t.type === 'OP' && t.postfix && t.value === 'NOT') {
      output.push(t);
      continue;
    }
    
    // Prefix unary operators
    if (t.type === 'OP' && t.unary && !t.postfix) {
      stack.push(t);
      continue;
    }
    
    // Binary operators
    if (t.type === 'OP' && !t.unary) {
      while (stack.length) {
        const top = stack[stack.length - 1];
        if (
          top.type === 'OP' && (
            (top.precedence > t.precedence) ||
            (top.precedence === t.precedence && t.associativity === 'left')
          )
        ) {
          output.push(stack.pop());
        } else {
          break;
        }
      }
      stack.push(t);
      continue;
    }
    
    // Left parenthesis
    if (t.type === 'LP') {
      stack.push(t);
      continue;
    }
    
    // Right parenthesis
    if (t.type === 'RP') {
      while (stack.length && stack[stack.length - 1].type !== 'LP') {
        output.push(stack.pop());
      }
      if (!stack.length) {
        throw new Error("Kurung buka '(' tidak memiliki pasangan kurung tutup ')'");
      }
      stack.pop(); // Remove LP
      continue;
    }
  }
  
  // Empty remaining stack
  while (stack.length) {
    const s = stack.pop();
    if (s.type === 'LP' || s.type === 'RP') {
      throw new Error("Kurung tidak seimbang - ada kurung yang tidak tertutup dengan benar");
    }
    output.push(s);
  }
  
  return output;
}

/* =============================================================================
   4. RPN EVALUATOR
   Evaluates RPN expression with given variable environment
============================================================================= */
/**
 * Evaluate RPN expression
 * @param {Array} rpn - Tokens in RPN order
 * @param {Object} env - Variable values {A: 0, B: 1, ...}
 * @returns {number} Result (0 or 1)
 */
function evalRPN(rpn, env) {
  const stack = [];
  
  for (const token of rpn) {
    if (token.type === 'NUM') {
      stack.push(!!token.value);
    } 
    else if (token.type === 'VAR') {
      if (!(token.value in env)) {
        throw new Error(`Variabel ${token.value} tidak didefinisikan dalam environment`);
      }
      stack.push(!!env[token.value]);
    } 
    else if (token.type === 'OP') {
      if (token.value === 'NOT') {
        if (stack.length < 1) {
          throw new Error("Operator NOT membutuhkan 1 operand");
        }
        const a = stack.pop();
        stack.push(!a);
      } else {
        if (stack.length < 2) {
          throw new Error(`Operator ${token.value} membutuhkan 2 operand`);
        }
        const b = stack.pop();
        const a = stack.pop();
        
        if (token.value === 'AND') {
          stack.push(a && b);
        } else if (token.value === 'OR') {
          stack.push(a || b);
        } else if (token.value === 'XOR') {
          stack.push(Boolean(a) !== Boolean(b));
        } else {
          throw new Error(`Operator tidak dikenal: ${token.value}`);
        }
      }
    }
  }
  
  if (stack.length !== 1) {
    throw new Error("Ekspresi tidak valid - periksa sintaks dengan teliti");
  }
  
  return stack[0] ? 1 : 0;
}

/* =============================================================================
   5. QUINE-MCCLUSKEY ALGORITHM
   Boolean function minimization algorithm
============================================================================= */

/**
 * Count number of 1's in binary string
 */
function countOnes(binStr) {
  return binStr.split('').filter(c => c === '1').length;
}

/**
 * Check if two binary strings differ by exactly 1 bit
 */
function canCombine(a, b) {
  let diff = 0;
  for (let i = 0; i < a.length; i++) {
    if (a[i] !== b[i]) diff++;
    if (diff > 1) return false;
  }
  return diff === 1;
}

/**
 * Combine two binary strings (differing bit becomes '-')
 */
function combine(a, b) {
  let result = '';
  for (let i = 0; i < a.length; i++) {
    result += (a[i] === b[i]) ? a[i] : '-';
  }
  return result;
}

/**
 * Check if implicant covers a minterm
 */
function covers(implicant, mintermBin) {
  for (let i = 0; i < implicant.length; i++) {
    if (implicant[i] === '-') continue;
    if (implicant[i] !== mintermBin[i]) return false;
  }
  return true;
}

/**
 * Main Quine-McCluskey minimization algorithm
 * @param {Array} minterms - Array of minterm indices
 * @param {Array} dontcares - Array of don't care indices
 * @param {Array} varNames - Variable names
 * @param {string} mode - 'SOP' or 'POS'
 * @returns {Object} {implicants: [], result: string}
 */
function qmSimplify(minterms, dontcares, varNames, mode = 'SOP') {
  const allTerms = [...minterms, ...dontcares];
  if (!allTerms.length) {
    return { implicants: [], result: mode === 'SOP' ? '0' : '1' };
  }
  
  const W = varNames.length;
  const bins = allTerms.map(m => toBin(m, W));
  let groups = {};
  
  // Phase 1: Group by number of 1's
  for (const b of bins) {
    const k = countOnes(b);
    if (!groups[k]) groups[k] = [];
    groups[k].push({ bin: b, used: false, from: [b] });
  }

  let newGroups = {};
  let anyCombined = true;
  const allCombinedLevels = [];

  // Phase 2: Iterative combination
  while (anyCombined) {
    anyCombined = false;
    newGroups = {};
    const keys = Object.keys(groups).map(Number).sort((a, b) => a - b);
    
    // Combine adjacent groups
    for (let idx = 0; idx < keys.length - 1; idx++) {
      const k1 = keys[idx];
      const k2 = keys[idx + 1];
      const g1 = groups[k1] || [];
      const g2 = groups[k2] || [];
      
      for (const a of g1) {
        for (const b of g2) {
          if (canCombine(a.bin, b.bin)) {
            const c = combine(a.bin, b.bin);
            const ones = countOnes(c.replace(/-/g, ''));
            const item = {
              bin: c,
              used: false,
              from: [...new Set([...(a.from || []), ...(b.from || [])])]
            };
            
            if (!newGroups[ones]) newGroups[ones] = [];
            newGroups[ones].push(item);
            
            a.used = true;
            b.used = true;
            anyCombined = true;
          }
        }
      }
    }
    
    // Deduplicate new groups
    for (const k in newGroups) {
      const unique = [];
      const seen = new Set();
      for (const it of newGroups[k]) {
        const key = it.bin + '|' + (it.from || []).join(',');
        if (!seen.has(key)) {
          seen.add(key);
          unique.push(it);
        }
      }
      newGroups[k] = unique;
    }
    
    // Collect prime implicants (unused terms)
    const primes = [];
    for (const k in groups) {
      for (const it of groups[k]) {
        if (!it.used) primes.push(it.bin);
      }
    }
    allCombinedLevels.push(primes);
    groups = newGroups;
  }
  
  // Phase 3: Collect all prime implicants
  const finalPrimes = new Set();
  for (const arr of allCombinedLevels) {
    for (const p of arr) finalPrimes.add(p);
  }
  for (const k in groups) {
    for (const it of groups[k]) finalPrimes.add(it.bin);
  }
  const primeList = Array.from(finalPrimes);

  // Phase 4: Prime implicant chart (cover only actual minterms, not don't cares)
  const minBin = minterms.map(m => toBin(m, W));
  const cover = {};
  
  for (let i = 0; i < minBin.length; i++) {
    cover[i] = [];
    for (let j = 0; j < primeList.length; j++) {
      if (covers(primeList[j], minBin[i])) {
        cover[i].push(j);
      }
    }
  }
  
  // Phase 5: Find essential prime implicants
  const chosen = new Set();
  const coveredRows = new Set();
  
  for (let i = 0; i < minBin.length; i++) {
    if (cover[i].length === 1) {
      const j = cover[i][0];
      chosen.add(j);
    }
  }
  
  // Helper: Mark covered rows
  const markCovered = () => {
    let changed = false;
    for (let i = 0; i < minBin.length; i++) {
      if (coveredRows.has(i)) continue;
      for (const j of (cover[i] || [])) {
        if (chosen.has(j)) {
          coveredRows.add(i);
          changed = true;
          break;
        }
      }
    }
    return changed;
  };
  markCovered();

  // Phase 6: Greedy covering for remaining rows
  while (coveredRows.size < minBin.length) {
    let bestJ = -1;
    let bestCoverCount = -1;
    
    for (let j = 0; j < primeList.length; j++) {
      if (!chosen.has(j)) {
        let count = 0;
        for (let i = 0; i < minBin.length; i++) {
          if (coveredRows.has(i)) continue;
          if (cover[i].includes(j)) count++;
        }
        if (count > bestCoverCount) {
          bestCoverCount = count;
          bestJ = j;
        }
      }
    }
    
    if (bestJ === -1) break; // Should not happen if input is valid
    chosen.add(bestJ);
    markCovered();
  }

  // Phase 7: Convert to SOP or POS
  const implicants = Array.from(chosen).map(j => primeList[j]);
  
  if (mode === 'SOP') {
    const sop = implicantsToSOP(implicants, varNames);
    return { implicants, result: sop };
  } else {
    const pos = implicantsToPOS(implicants, varNames);
    return { implicants, result: pos };
  }
}

/**
 * Convert implicants to SOP (Sum of Products) form
 */
function implicantsToSOP(impls, vars) {
  if (!impls.length) return '0';
  
  const parts = impls.map(mask => {
    let s = '';
    for (let i = 0; i < mask.length; i++) {
      if (mask[i] === '-') continue;
      const v = vars[i];
      s += (mask[i] === '1') ? v : (v + "'");
    }
    return s || '1';
  });
  
  return parts.join(' + ');
}

/**
 * Convert implicants to POS (Product of Sums) form
 */
function implicantsToPOS(impls, vars) {
  if (!impls.length) return '1';
  
  const parts = impls.map(mask => {
    let s = '';
    for (let i = 0; i < mask.length; i++) {
      if (mask[i] === '-') continue;
      const v = vars[i];
      if (s) s += ' + ';
      s += (mask[i] === '0') ? v : (v + "'");
    }
    return s ? '(' + s + ')' : '1';
  });
  
  return parts.join('');
}

/* =============================================================================
   6. K-MAP LAYOUT GENERATION
   Generate K-Map structure based on number of variables
============================================================================= */
/**
 * Generate K-Map layout for given number of variables
 * @param {number} nVars - Number of variables (1-4)
 * @returns {Object} Layout configuration with Gray code ordering
 */
function kmapLayoutForVars(nVars) {
  if (nVars === 1) {
    return {
      rows: [0, 1],
      cols: [0],
      rowVars: ['A'],
      colVars: [],
      index({ r, c }) {
        return GRAY2[r];
      }
    };
  }
  
  if (nVars === 2) {
    return {
      rows: GRAY2,
      cols: GRAY2,
      rowVars: ['A'],
      colVars: ['B'],
      index({ r, c }) {
        const A = GRAY2[r];
        const B = GRAY2[c];
        return (A << 1) | B;
      }
    };
  }
  
  if (nVars === 3) {
    return {
      rows: GRAY2,
      cols: GRAY4,
      rowVars: ['A'],
      colVars: ['B', 'C'],
      index({ r, c }) {
        const A = GRAY2[r];
        const BC = GRAY4[c];
        const B = (BC >> 1) & 1;
        const C = BC & 1;
        return (A << 2) | (B << 1) | C;
      }
    };
  }
  
  if (nVars === 4) {
    return {
      rows: GRAY4,
      cols: GRAY4,
      rowVars: ['A', 'B'],
      colVars: ['C', 'D'],
      index({ r, c }) {
        const AB = GRAY4[r];
        const CD = GRAY4[c];
        const A = (AB >> 1) & 1;
        const B = AB & 1;
        const C = (CD >> 1) & 1;
        const D = CD & 1;
        return (A << 3) | (B << 2) | (C << 1) | D;
      }
    };
  }
  
  return null;
}

/**
 * Format axis label for K-Map
 */
function prettyAxisLabel(vars) {
  if (!vars.length) return '‚Äî';
  return vars.join('');
}

/* =============================================================================
   7. TRUTH TABLE GENERATION
============================================================================= */
/**
 * Build complete truth table for given variables and expression
 * @param {Array} vars - Variable names
 * @param {Array} rpn - RPN expression
 * @returns {Array} Array of {m: minterm_index, env: {A:0, B:1}, y: output}
 */
function buildTruthTable(vars, rpn) {
  const rows = [];
  const n = vars.length;
  const total = 1 << n; // 2^n combinations
  
  for (let m = 0; m < total; m++) {
    const env = {};
    // Convert minterm index to variable values
    for (let i = 0; i < n; i++) {
      env[vars[i]] = (m >> (n - 1 - i)) & 1;
    }
    const y = rpn ? evalRPN(rpn, env) : 0;
    rows.push({ m, env, y });
  }
  
  return rows;
}

/* =============================================================================
   8. APPLICATION STATE & DOM ELEMENTS
============================================================================= */
const els = {
  // Input
  expr: $('expr'),
  mintermIO: $('minterm-io'),
  
  // Buttons
  btnEval: $('btn-eval'),
  btnClear: $('btn-clear'),
  btnValidate: $('btn-validate'),
  btnSimplify: $('btn-simplify'),
  btnReset: $('btn-reset'),
  btnExportImg: $('btn-export-img'),
  btnImport: $('btn-import'),
  btnExport: $('btn-export'),
  modeSOP: $('mode-sop'),
  modePOS: $('mode-pos'),
  themeToggle: $('theme-toggle'),
  
  // Display
  errorMessage: $('error-message'),
  successMessage: $('success-message'),
  varsPill: $('vars-pill'),
  mintermsPill: $('minterms-pill'),
  benchmark: $('benchmark'),
  benchTime: $('bench-time'),
  benchCells: $('bench-cells'),
  benchComplexity: $('bench-complexity'),
  ttHead: $('ttbl').querySelector('thead'),
  ttBody: $('ttbl').querySelector('tbody'),
  kmap: $('kmap'),
  rowlabel: $('rowlabel'),
  collabel: $('collabel'),
  outSimplified: $('out-simplified'),
  resultLabel: $('result-label'),
  mintermLabel: $('minterm-label'),
  
  // Stats
  statEvaluations: $('stat-evaluations'),
  statVars: $('stat-vars'),
  statMinterms: $('stat-minterms'),
  statTime: $('stat-time')
};

// Application state
let currentVars = [];
let currentRPN = null;
let currentKMap = { vars: [], n: 0, layout: null, cells: [], total: 0 };
let currentMode = 'SOP';
let stats = {
  evaluations: 0,
  lastVars: 0,
  lastMinterms: 0,
  lastTime: 0
};

/* =============================================================================
   9. UI HELPER FUNCTIONS
============================================================================= */
function showError(message) {
  els.errorMessage.textContent = '‚ùå ' + message;
  els.errorMessage.classList.add('show');
  els.successMessage.classList.remove('show');
}

function showSuccess(message) {
  els.successMessage.textContent = '‚úÖ ' + message;
  els.successMessage.classList.add('show');
  els.errorMessage.classList.remove('show');
}

function hideMessages() {
  els.errorMessage.classList.remove('show');
  els.successMessage.classList.remove('show');
}

function updateStats() {
  els.statEvaluations.textContent = stats.evaluations;
  els.statVars.textContent = stats.lastVars;
  els.statMinterms.textContent = stats.lastMinterms;
  els.statTime.textContent = stats.lastTime.toFixed(2) + 'ms';
}

function setPills(vars, minterms, dontcares) {
  els.varsPill.textContent = `üìä Variables: ${vars.length ? vars.join(', ') : '‚Äî'}`;
  const dcStr = dontcares.length ? ` +d(${dontcares.join(',')})` : '';
  els.mintermsPill.textContent = `üéØ Minterms: ${minterms.length ? minterms.join(',') + dcStr : '‚Äî'}`;
}

function renderTruthTable(vars, rows) {
  const thv = vars.map(v => `<th>${v}</th>`).join('');
  els.ttHead.innerHTML = `<tr>${thv}<th>Y</th><th class="muted">m</th></tr>`;
  
  els.ttBody.innerHTML = rows.map(r => {
    const vs = vars.map(v => `<td>${r.env[v]}</td>`).join('');
    return `<tr>${vs}<td><b>${r.y}</b></td><td class="muted">${r.m}</td></tr>`;
  }).join('');
}

function initKMap(vars) {
  const n = Math.min(vars.length, MAX_VARS);
  const layout = kmapLayoutForVars(n);
  currentKMap = { 
    vars: vars.slice(0, n), 
    n, 
    layout, 
    cells: [], 
    total: (1 << n) 
  };
  currentKMap.cells = new Array(currentKMap.total).fill(0);

  if (!layout) {
    els.kmap.innerHTML = `<div class="muted">‚ö†Ô∏è K-Map tersedia hanya hingga 4 variabel. Variabel terdeteksi: ${vars.length}.</div>`;
    els.rowlabel.textContent = '‚Äî';
    els.collabel.textContent = '‚Äî';
    return;
  }

  els.rowlabel.textContent = prettyAxisLabel(layout.rowVars);
  els.collabel.textContent = prettyAxisLabel(layout.colVars);

  const rows = layout.rows.length || 1;
  const cols = layout.cols.length || 1;

  els.kmap.style.gridTemplateColumns = `repeat(${cols}, 62px)`;
  els.kmap.innerHTML = '';

  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      const idx = layout.index({ r, c });
      const div = document.createElement('div');
      div.className = 'kcell';
      div.dataset.index = idx;
      div.textContent = '0';
      div.title = `m${idx} - Klik untuk toggle (0‚Üí1‚Üíd‚Üí0)`;
      
      div.addEventListener('click', () => {
        const val = currentKMap.cells[idx];
        currentKMap.cells[idx] = val === 0 ? 1 : (val === 1 ? 'd' : 0);
        updateKMapCell(div, idx);
      });
      
      els.kmap.appendChild(div);
    }
  }
}

function updateKMapCell(div, idx) {
  const val = currentKMap.cells[idx];
  div.classList.remove('on', 'dc');
  
  if (val === 1) {
    div.classList.add('on');
    div.textContent = '1';
  } else if (val === 'd') {
    div.classList.add('dc');
    div.textContent = 'd';
  } else {
    div.textContent = '0';
  }
}

function paintKMapFromData(minterms, dontcares) {
  if (!currentKMap.layout) return;
  
  for (let i = 0; i < currentKMap.total; i++) {
    currentKMap.cells[i] = 0;
  }
  
  for (const m of minterms) {
    if (m >= 0 && m < currentKMap.total) {
      currentKMap.cells[m] = 1;
    }
  }
  
  for (const d of dontcares) {
    if (d >= 0 && d < currentKMap.total) {
      currentKMap.cells[d] = 'd';
    }
  }
  
  const children = els.kmap.children;
  for (let k = 0; k < children.length; k++) {
    const idx = Number(children[k].dataset.index);
    updateKMapCell(children[k], idx);
  }
}

function collectDataFromKMap() {
  const minterms = [];
  const dontcares = [];
  
  for (let i = 0; i < currentKMap.total; i++) {
    if (currentKMap.cells[i] === 1) minterms.push(i);
    else if (currentKMap.cells[i] === 'd') dontcares.push(i);
  }
  
  return { 
    minterms: minterms.sort((a, b) => a - b), 
    dontcares: dontcares.sort((a, b) => a - b) 
  };
}

function simplifyFromKMap() {
  const n = currentKMap.n;
  const vars = currentKMap.vars;
  
  if (n === 0) {
    const y = currentKMap.cells[0] === 1 ? '1' : '0';
    els.outSimplified.textContent = y;
    return;
  }
  
  const { minterms: minterms1, dontcares } = collectDataFromKMap();
  let effectiveMinterms = minterms1;
  
  if (currentMode === 'POS') {
    const allTerms = new Array(currentKMap.total).fill(0).map((_, i) => i);
    const onAndDC = new Set([...minterms1, ...dontcares]);
    effectiveMinterms = allTerms.filter(m => !onAndDC.has(m));
  }
  
  const startTime = performance.now();
  const { result } = qmSimplify(effectiveMinterms, dontcares, vars, currentMode);
  const endTime = performance.now();
  
  const timeTaken = endTime - startTime;
  els.outSimplified.textContent = result;
  els.benchTime.textContent = `${timeTaken.toFixed(3)}ms`;
  els.benchCells.textContent = `${effectiveMinterms.length} terms, ${dontcares.length} DC`;
  els.benchComplexity.textContent = `O(3^${vars.length} √ó ${vars.length}¬≤)`;
  els.benchmark.style.display = 'flex';
  
  stats.lastTime = timeTaken;
  stats.lastMinterms = minterms1.length;
  updateStats();
}

function parseTermInput(input) {
  const minterms = [];
  const dontcares = [];
  
  const dcMatch = input.match(/\+\s*d\s*\(([^)]+)\)/i);
  let mainPart = input;
  
  if (dcMatch) {
    const dcPart = dcMatch[1];
    dontcares.push(...dcPart.split(/[,\s]+/)
      .map(s => s.trim())
      .filter(Boolean)
      .map(Number)
      .filter(n => Number.isInteger(n) && n >= 0));
    mainPart = input.substring(0, dcMatch.index);
  }
  
  minterms.push(...mainPart.split(/[,\s]+/)
    .map(s => s.trim())
    .filter(Boolean)
    .map(Number)
    .filter(n => Number.isInteger(n) && n >= 0));
  
  return { minterms, dontcares };
}

/* =============================================================================
   10. IMAGE EXPORT FUNCTIONALITY
============================================================================= */
function exportKMapAsImage() {
  const kmapEl = els.kmap;
  
  if (!currentKMap.layout) {
    showError('K-Map tidak tersedia untuk ekspor');
    return;
  }
  
  const canvas = document.createElement('canvas');
  
  // Dimensions
  const cellSize = 90;
  const cellGap = 4;
  const rows = currentKMap.layout.rows.length || 1;
  const cols = currentKMap.layout.cols.length || 1;
  
  const kmapWidth = cols * cellSize + (cols - 1) * cellGap;
  const kmapHeight = rows * cellSize + (rows - 1) * cellGap;
  
  const padding = 60;
  const headerHeight = 200;
  const legendHeight = 80;
  const footerHeight = 60;
  
  canvas.width = Math.max(800, kmapWidth + padding * 2);
  canvas.height = headerHeight + kmapHeight + legendHeight + footerHeight + padding * 2;
  
  const ctx = canvas.getContext('2d');
  const isDark = document.body.dataset.theme === 'dark';
  
  // Background gradient
  const bgGrad = ctx.createLinearGradient(0, 0, 0, canvas.height);
  if (isDark) {
    bgGrad.addColorStop(0, '#0f0f1e');
    bgGrad.addColorStop(0.5, '#1a1a2e');
    bgGrad.addColorStop(1, '#0f0f1e');
  } else {
    bgGrad.addColorStop(0, '#f7fafc');
    bgGrad.addColorStop(0.5, '#edf2f7');
    bgGrad.addColorStop(1, '#e2e8f0');
  }
  ctx.fillStyle = bgGrad;
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  // Decorative background shapes
  ctx.globalAlpha = 0.12;
  
  const shape1 = ctx.createRadialGradient(80, 80, 0, 80, 80, 200);
  shape1.addColorStop(0, '#667eea');
  shape1.addColorStop(1, 'transparent');
  ctx.fillStyle = shape1;
  ctx.beginPath();
  ctx.arc(80, 80, 200, 0, Math.PI * 2);
  ctx.fill();
  
  const shape2 = ctx.createRadialGradient(canvas.width - 80, canvas.height / 2, 0, canvas.width - 80, canvas.height / 2, 180);
  shape2.addColorStop(0, '#f093fb');
  shape2.addColorStop(1, 'transparent');
  ctx.fillStyle = shape2;
  ctx.beginPath();
  ctx.arc(canvas.width - 80, canvas.height / 2, 180, 0, Math.PI * 2);
  ctx.fill();
  
  const shape3 = ctx.createRadialGradient(canvas.width / 2, canvas.height - 50, 0, canvas.width / 2, canvas.height - 50, 150);
  shape3.addColorStop(0, '#4facfe');
  shape3.addColorStop(1, 'transparent');
  ctx.fillStyle = shape3;
  ctx.beginPath();
  ctx.arc(canvas.width / 2, canvas.height - 50, 150, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.globalAlpha = 1.0;
  
  // Header card
  const headerY = 40;
  const headerCardHeight = 140;
  
  ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
  ctx.shadowBlur = 20;
  ctx.shadowOffsetY = 8;
  
  const headerGrad = ctx.createLinearGradient(0, headerY, 0, headerY + headerCardHeight);
  if (isDark) {
    headerGrad.addColorStop(0, 'rgba(255, 255, 255, 0.08)');
    headerGrad.addColorStop(1, 'rgba(255, 255, 255, 0.04)');
  } else {
    headerGrad.addColorStop(0, 'rgba(255, 255, 255, 0.95)');
    headerGrad.addColorStop(1, 'rgba(255, 255, 255, 0.9)');
  }
  ctx.fillStyle = headerGrad;
  roundRect(ctx, padding, headerY, canvas.width - padding * 2, headerCardHeight, 20);
  ctx.fill();
  
  ctx.shadowBlur = 0;
  ctx.shadowOffsetY = 0;
  
  // Header border
  ctx.strokeStyle = isDark ? 'rgba(255, 255, 255, 0.15)' : 'rgba(0, 0, 0, 0.1)';
  ctx.lineWidth = 2;
  roundRect(ctx, padding, headerY, canvas.width - padding * 2, headerCardHeight, 20);
  ctx.stroke();
  
  // Accent bar
  const accentGrad = ctx.createLinearGradient(padding, headerY, canvas.width - padding, headerY);
  accentGrad.addColorStop(0, '#667eea');
  accentGrad.addColorStop(0.5, '#764ba2');
  accentGrad.addColorStop(1, '#667eea');
  ctx.fillStyle = accentGrad;
  roundRect(ctx, padding, headerY, canvas.width - padding * 2, 4, 2);
  ctx.fill();
  
  // Icon
  const iconSize = 56;
  const iconX = padding + 30;
  const iconY = headerY + 30;
  
  const iconGrad = ctx.createLinearGradient(iconX, iconY, iconX, iconY + iconSize);
  iconGrad.addColorStop(0, '#667eea');
  iconGrad.addColorStop(1, '#764ba2');
  ctx.fillStyle = iconGrad;
  ctx.shadowColor = 'rgba(102, 126, 234, 0.4)';
  ctx.shadowBlur = 12;
  roundRect(ctx, iconX, iconY, iconSize, iconSize, 14);
  ctx.fill();
  ctx.shadowBlur = 0;
  
  ctx.font = '36px Arial';
  ctx.fillStyle = 'white';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('üó∫Ô∏è', iconX + iconSize / 2, iconY + iconSize / 2);
  
  // Title and info
  const textX = iconX + iconSize + 24;
  
  ctx.fillStyle = isDark ? '#ffffff' : '#1a202c';
  ctx.font = 'bold 32px "Space Grotesk", sans-serif';
  ctx.textAlign = 'left';
  ctx.textBaseline = 'top';
  ctx.fillText('Karnaugh Map', textX, iconY + 4);
  
  ctx.font = '15px "JetBrains Mono", monospace';
  ctx.fillStyle = isDark ? '#a0aec0' : '#64748b';
  ctx.fillText('Kelompok 1 ‚Äî Rangkaian Digital', textX, iconY + 42);
  
  // Mode badge
  const badgeX = textX;
  const badgeY = iconY + 70;
  const badgeWidth = 120;
  const badgeHeight = 32;
  
  const badgeGrad = ctx.createLinearGradient(badgeX, badgeY, badgeX + badgeWidth, badgeY);
  badgeGrad.addColorStop(0, '#667eea');
  badgeGrad.addColorStop(1, '#764ba2');
  ctx.fillStyle = badgeGrad;
  ctx.shadowColor = 'rgba(102, 126, 234, 0.3)';
  ctx.shadowBlur = 8;
  roundRect(ctx, badgeX, badgeY, badgeWidth, badgeHeight, 16);
  ctx.fill();
  ctx.shadowBlur = 0;
  
  ctx.font = 'bold 14px "Space Grotesk", sans-serif';
  ctx.fillStyle = 'white';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(`${currentMode} Mode`, badgeX + badgeWidth / 2, badgeY + badgeHeight / 2);
  
  // Variables info
  const infoX = badgeX + badgeWidth + 24;
  ctx.font = '14px "JetBrains Mono", monospace';
  ctx.fillStyle = isDark ? '#94a3b8' : '#64748b';
  ctx.textAlign = 'left';
  ctx.textBaseline = 'middle';
  const rowLabel = prettyAxisLabel(currentKMap.layout.rowVars);
  const colLabel = prettyAxisLabel(currentKMap.layout.colVars);
  ctx.fillText(`Row: ${rowLabel}`, infoX, badgeY + 8);
  ctx.fillText(`Col: ${colLabel}`, infoX, badgeY + 24);
  
  // K-Map container
  const kmapY = headerY + headerCardHeight + 40;
  const kmapX = (canvas.width - kmapWidth) / 2;
  
  ctx.shadowColor = 'rgba(0, 0, 0, 0.2)';
  ctx.shadowBlur = 15;
  ctx.shadowOffsetY = 6;
  
  const kmapContainerGrad = ctx.createLinearGradient(0, kmapY - 30, 0, kmapY + kmapHeight + 30);
  if (isDark) {
    kmapContainerGrad.addColorStop(0, 'rgba(255, 255, 255, 0.06)');
    kmapContainerGrad.addColorStop(1, 'rgba(255, 255, 255, 0.03)');
  } else {
    kmapContainerGrad.addColorStop(0, 'rgba(255, 255, 255, 0.95)');
    kmapContainerGrad.addColorStop(1, 'rgba(255, 255, 255, 0.85)');
  }
  ctx.fillStyle = kmapContainerGrad;
  roundRect(ctx, kmapX - 30, kmapY - 30, kmapWidth + 60, kmapHeight + 60, 16);
  ctx.fill();
  
  ctx.shadowBlur = 0;
  ctx.shadowOffsetY = 0;
  
  ctx.strokeStyle = isDark ? 'rgba(255, 255, 255, 0.12)' : 'rgba(0, 0, 0, 0.08)';
  ctx.lineWidth = 2;
  roundRect(ctx, kmapX - 30, kmapY - 30, kmapWidth + 60, kmapHeight + 60, 16);
  ctx.stroke();
  
  // Draw K-Map cells
  const children = kmapEl.children;
  
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      const x = kmapX + c * (cellSize + cellGap);
      const y = kmapY + r * (cellSize + cellGap);
      const cellIdx = r * cols + c;
      const dataIdx = Number(children[cellIdx].dataset.index);
      const val = currentKMap.cells[dataIdx];
      
      // Cell shadow
      ctx.shadowColor = 'rgba(0, 0, 0, 0.15)';
      ctx.shadowBlur = 6;
      ctx.shadowOffsetY = 3;
      
      // Cell gradient
      let cellGrad;
      if (val === 1) {
        cellGrad = ctx.createLinearGradient(x, y, x, y + cellSize);
        cellGrad.addColorStop(0, '#4facfe');
        cellGrad.addColorStop(1, '#00f2fe');
      } else if (val === 'd') {
        cellGrad = ctx.createLinearGradient(x, y, x, y + cellSize);
        cellGrad.addColorStop(0, '#fa709a');
        cellGrad.addColorStop(1, '#fee140');
      } else {
        cellGrad = ctx.createLinearGradient(x, y, x, y + cellSize);
        if (isDark) {
          cellGrad.addColorStop(0, 'rgba(255,255,255,0.06)');
          cellGrad.addColorStop(1, 'rgba(255,255,255,0.03)');
        } else {
          cellGrad.addColorStop(0, '#ffffff');
          cellGrad.addColorStop(1, '#f8fafc');
        }
      }
      
      ctx.fillStyle = cellGrad;
      roundRect(ctx, x, y, cellSize, cellSize, 14);
      ctx.fill();
      
      ctx.shadowBlur = 0;
      ctx.shadowOffsetY = 0;
      
      // Cell border with glow
      if (val === 1) {
        ctx.strokeStyle = '#00f2fe';
        ctx.lineWidth = 3;
        ctx.shadowColor = 'rgba(0, 242, 254, 0.4)';
        ctx.shadowBlur = 12;
      } else if (val === 'd') {
        ctx.strokeStyle = '#fee140';
        ctx.lineWidth = 3;
        ctx.shadowColor = 'rgba(254, 225, 64, 0.4)';
        ctx.shadowBlur = 12;
      } else {
        ctx.strokeStyle = isDark ? 'rgba(255, 255, 255, 0.12)' : 'rgba(0, 0, 0, 0.1)';
        ctx.lineWidth = 2;
        ctx.shadowBlur = 0;
      }
      roundRect(ctx, x, y, cellSize, cellSize, 14);
      ctx.stroke();
      
      ctx.shadowBlur = 0;
      
      // Cell value
      ctx.fillStyle = val ? '#ffffff' : (isDark ? '#e2e8f0' : '#1a202c');
      ctx.font = 'bold 36px "JetBrains Mono", monospace';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(
        val === 'd' ? 'd' : (val || '0'),
        x + cellSize / 2,
        y + cellSize / 2 - 4
      );
      
      // Minterm label
      ctx.font = '11px "JetBrains Mono", monospace';
      ctx.fillStyle = isDark ? '#64748b' : '#94a3b8';
      ctx.fillText(`m${dataIdx}`, x + cellSize / 2, y + cellSize - 14);
    }
  }
  
  // Legend
  const legendY = kmapY + kmapHeight + 50;
  const legendItemWidth = 120;
  const legendBoxSize = 32;
  const totalLegendWidth = legendItemWidth * 3;
  const legendStartX = (canvas.width - totalLegendWidth) / 2;
  
  ctx.font = '14px "Space Grotesk", sans-serif';
  ctx.textAlign = 'left';
  ctx.textBaseline = 'middle';
  
  // Legend items
  const legendItems = [
    { label: '0 (Off)', color1: isDark ? 'rgba(255,255,255,0.06)' : '#ffffff', color2: isDark ? 'rgba(255,255,255,0.03)' : '#f8fafc', border: isDark ? 'rgba(255,255,255,0.12)' : 'rgba(0,0,0,0.1)' },
    { label: '1 (On)', color1: '#4facfe', color2: '#00f2fe', border: '#00f2fe', glow: 'rgba(0,242,254,0.3)' },
    { label: 'd (DC)', color1: '#fa709a', color2: '#fee140', border: '#fee140', glow: 'rgba(254,225,64,0.3)' }
  ];
  
  legendItems.forEach((item, i) => {
    const x = legendStartX + i * legendItemWidth;
    
    const boxGrad = ctx.createLinearGradient(x, legendY, x, legendY + legendBoxSize);
    boxGrad.addColorStop(0, item.color1);
    boxGrad.addColorStop(1, item.color2);
    ctx.fillStyle = boxGrad;
    
    if (item.glow) {
      ctx.shadowColor = item.glow;
      ctx.shadowBlur = 8;
    }
    
    roundRect(ctx, x, legendY, legendBoxSize, legendBoxSize, 8);
    ctx.fill();
    
    ctx.shadowBlur = 0;
    
    ctx.strokeStyle = item.border;
    ctx.lineWidth = 2;
    roundRect(ctx, x, legendY, legendBoxSize, legendBoxSize, 8);
    ctx.stroke();
    
    ctx.fillStyle = isDark ? '#a0aec0' : '#4a5568';
    ctx.font = 'bold 13px "Space Grotesk", sans-serif';
    ctx.fillText(item.label, x + legendBoxSize + 10, legendY + legendBoxSize / 2);
  });
  
  // Footer
  ctx.font = '12px "Space Grotesk", sans-serif';
  ctx.fillStyle = isDark ? '#64748b' : '#94a3b8';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'bottom';
  ctx.fillText(
    `Generated by Boolean Algebra & K-Map Simulator ¬© ${new Date().getFullYear()} Kelompok 1`,
    canvas.width / 2,
    canvas.height - 20
  );
  
  // Download
  canvas.toBlob(blob => {
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
    a.download = `kmap_${currentMode}_${timestamp}.png`;
    a.click();
    URL.revokeObjectURL(url);
    showSuccess('K-Map berhasil diekspor sebagai PNGüé®‚ú®');
  });
}

// Helper function for rounded rectangles
function roundRect(ctx, x, y, width, height, radius) {
  ctx.beginPath();
  ctx.moveTo(x + radius, y);
  ctx.lineTo(x + width - radius, y);
  ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
  ctx.lineTo(x + width, y + height - radius);
  ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
  ctx.lineTo(x + radius, y + height);
  ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
  ctx.lineTo(x, y + radius);
  ctx.quadraticCurveTo(x, y, x + radius, y);
  ctx.closePath();
}

/* =============================================================================
   11. EVENT HANDLERS
============================================================================= */

// Evaluate Expression
els.btnEval.addEventListener('click', () => {
  hideMessages();

  try {
    const expr = els.expr.value.trim();
    
    if (!expr) {
      showError('Harap masukkan ekspresi Boolean');
      return;
    }
    
    const vars0 = extractVars(expr);
    
    if (vars0.length === 0) {
      showError('Tidak ada variabel yang terdeteksi dalam ekspresi');
      return;
    }
    
    if (vars0.length > MAX_TRUTH_TABLE_VARS) {
      showError(`Maksimal ${MAX_TRUTH_TABLE_VARS} variabel untuk tabel kebenaran`);
      return;
    }
    
    currentVars = vars0.slice(0, MAX_TRUTH_TABLE_VARS);
    currentRPN = toRPN(tokenize(expr));

    const rows = buildTruthTable(currentVars, currentRPN);
    renderTruthTable(currentVars, rows);

    const minFull = rows.filter(r => r.y === 1).map(r => r.m);
    const kVars = currentVars.slice(0, MAX_VARS);
    initKMap(kVars);

    if (currentVars.length <= MAX_VARS) {
      paintKMapFromData(minFull, []);      
      let effectiveMinterms = minFull;
      if (currentMode === 'POS') {
        const allTerms = new Array(currentKMap.total).fill(0).map((_, i) => i);
        const onAndDC = new Set(minFull);
        effectiveMinterms = allTerms.filter(m => !onAndDC.has(m));
      }

      const startTimeQM = performance.now();
      const { result } = qmSimplify(effectiveMinterms, [], kVars, currentMode);
      const endTimeQM = performance.now();
      
      const timeTaken = endTimeQM - startTimeQM;
      els.outSimplified.textContent = result;
      els.benchTime.textContent = `${timeTaken.toFixed(3)}ms`;
      els.benchCells.textContent = `${effectiveMinterms.length} terms`;
      els.benchComplexity.textContent = `O(3^${kVars.length} √ó ${kVars.length}¬≤)`;
      els.benchmark.style.display = 'flex';
      
      stats.lastTime = timeTaken;
      stats.lastMinterms = minFull.length;
    } else {
      els.outSimplified.textContent = '‚Äî (K-Map hanya untuk ‚â§4 variabel)';
      els.benchmark.style.display = 'none';
    }

    setPills(currentVars, minFull, []);
    
    stats.evaluations++;
    stats.lastVars = currentVars.length;
    updateStats();
    
    showSuccess(`Evaluasi berhasil! ${minFull.length} minterm ditemukan.`);
    
  } catch (e) {
    showError(e.message);
    setPills([], [], []);
    els.outSimplified.textContent = '‚Äî';
    els.benchmark.style.display = 'none';
  }
});

// Validate Syntax
els.btnValidate.addEventListener('click', () => {
  hideMessages();
  
  try {
    const expr = els.expr.value.trim();
    
    if (!expr) {
      showError('Harap masukkan ekspresi untuk divalidasi');
      return;
    }
    
    const tokens = tokenize(expr);
    const rpn = toRPN(tokens);
    const vars = extractVars(expr);
    
    showSuccess(`Sintaks valid! ${tokens.length} token, ${vars.length} variabel: ${vars.join(', ')}`);
  } catch (e) {
    showError('Sintaks tidak valid: ' + e.message);
  }
});

// Clear All
els.btnClear.addEventListener('click', () => {
  els.expr.value = '';
  currentVars = [];
  currentRPN = null;
  els.ttHead.innerHTML = '';
  els.ttBody.innerHTML = '';
  initKMap([]);
  els.outSimplified.textContent = '‚Äî';
  setPills([], [], []);
  els.mintermIO.value = '';
  els.benchmark.style.display = 'none';
  hideMessages();
  showSuccess('Semua data berhasil dibersihkan');
});

// Reset K-Map
els.btnReset.addEventListener('click', () => {
  paintKMapFromData([], []);
  els.outSimplified.textContent = '‚Äî';
  els.benchmark.style.display = 'none';
  showSuccess('K-Map berhasil direset');
});

// Simplify K-Map
els.btnSimplify.addEventListener('click', () => {
  hideMessages();
  
  try {
    simplifyFromKMap();
    showSuccess('Penyederhanaan berhasil menggunakan algoritma Quine-McCluskey');
  } catch (e) {
    showError('Gagal menyederhanakan: ' + e.message);
  }
});

// Import Minterm
els.btnImport.addEventListener('click', () => {
  hideMessages();
  
  try {
    const txt = els.mintermIO.value.trim();
    
    if (!txt) {
      paintKMapFromData([], []);
      els.outSimplified.textContent = '‚Äî';
      showError('Input minterm kosong');
      return;
    }
    
    const { minterms, dontcares } = parseTermInput(txt);
    
    if (minterms.length === 0 && dontcares.length === 0) {
      showError('Tidak ada minterm valid yang ditemukan');
      return;
    }
    
    paintKMapFromData(minterms, dontcares);
    simplifyFromKMap();
    setPills(currentKMap.vars, minterms, dontcares);
    
    showSuccess(`Berhasil mengimpor ${minterms.length} minterm, ${dontcares.length} don't care`);
  } catch (e) {
    showError('Format minterm tidak valid: ' + e.message);
  }
});

// Export Minterm
els.btnExport.addEventListener('click', () => {
  const { minterms, dontcares } = collectDataFromKMap();
  let result = minterms.join(',');
  if (dontcares.length) result += ` +d(${dontcares.join(',')})`;
  
  els.mintermIO.value = result;
  
  if (minterms.length === 0 && dontcares.length === 0) {
    showError('K-Map kosong, tidak ada yang diekspor');
  } else {
    showSuccess(`Berhasil mengekspor ${minterms.length} minterm, ${dontcares.length} don't care`);
  }
});

// Export Image
els.btnExportImg.addEventListener('click', () => {
  hideMessages();
  exportKMapAsImage();
});

// Mode Toggle: SOP
els.modeSOP.addEventListener('click', () => {
  currentMode = 'SOP';
  els.modeSOP.classList.add('active');
  els.modePOS.classList.remove('active');
  els.resultLabel.innerHTML = 'üéØ Hasil Penyederhanaan (SOP) <span class="tooltip-icon" data-tip="Sum of Products - bentuk penjumlahan dari product terms">?</span>';
  els.mintermLabel.innerHTML = 'üì• Import/Export Minterm <span class="tooltip-icon" data-tip="Format: 0,1,5,7 atau 0,1,5,7+d(2,3)">?</span>';
  
  if (currentKMap.layout) {
    simplifyFromKMap();
  }
});

// Mode Toggle: POS
els.modePOS.addEventListener('click', () => {
  currentMode = 'POS';
  els.modePOS.classList.add('active');
  els.modeSOP.classList.remove('active');
  els.resultLabel.innerHTML = 'üéØ Hasil Penyederhanaan (POS) <span class="tooltip-icon" data-tip="Product of Sums - bentuk perkalian dari sum terms">?</span>';
  els.mintermLabel.innerHTML = 'üì• Import/Export Maxterm <span class="tooltip-icon" data-tip="Format: 0,1,5,7 atau 0,1,5,7+d(2,3)">?</span>';
  
  if (currentKMap.layout) {
    simplifyFromKMap();
  }
});

// Theme Toggle
els.themeToggle.addEventListener('click', () => {
  const current = document.body.dataset.theme;
  const newTheme = current === 'dark' ? 'light' : 'dark';
  document.body.dataset.theme = newTheme;
  localStorage.setItem('theme', newTheme);
  els.themeToggle.textContent = newTheme === 'dark' ? 'üåô' : '‚òÄÔ∏è';
  
  showSuccess(`Tema berhasil diubah ke ${newTheme === 'dark' ? 'Dark' : 'Light'} mode`);
  setTimeout(hideMessages, 2000);
});

// Example Buttons
document.querySelectorAll('.example-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    els.expr.value = btn.dataset.expr;
    els.btnEval.click();
  });
});

// Keyboard Shortcuts
document.addEventListener('keydown', (e) => {
  if (e.ctrlKey || e.metaKey) {
    if (e.key === 'Enter') {
      e.preventDefault();
      els.btnEval.click();
    } else if (e.key === 'k') {
      e.preventDefault();
      els.expr.focus();
    }
  }
});

/* =============================================================================
   12. INITIALIZATION
============================================================================= */
function init() {
  // Load saved theme
  const savedTheme = localStorage.getItem('theme') || 'dark';
  document.body.dataset.theme = savedTheme;
  els.themeToggle.textContent = savedTheme === 'dark' ? 'üåô' : '‚òÄÔ∏è';
  
  // Initialize K-Map
  initKMap([]);
  setPills([], [], []);
  updateStats();
  
  // Auto-focus input
  els.expr.focus();
  
  console.log('%cüéì Boolean Algebra & K-Map Simulator', 'font-size: 16px; font-weight: bold; color: #46b07b;');
  console.log('%cKelompok 1 - Rangkaian Digital', 'font-size: 12px; color: #5aa4ff;');
  console.log('%cKeyboard Shortcuts:', 'font-size: 12px; font-weight: bold; margin-top: 8px;');
  console.log('  Ctrl+Enter: Evaluate expression');
  console.log('  Ctrl+K: Focus input field');
}

// Run initialization
init();
</script>
</body>
</html>